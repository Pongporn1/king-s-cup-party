/* eslint-disable @typescript-eslint/no-explicit-any */
// MySQL-backed Supabase-compatible client
// This provides a Supabase-like interface that uses MySQL API instead

import socketClient from "@/lib/socketClient";

const API_URL = import.meta.env.VITE_API_URL || "http://localhost:3001";

// Helper function to convert table names from underscore to dash for API endpoints
const toApiEndpoint = (table: string) => table.replace(/_/g, "-");

// Create a mock Supabase client that uses MySQL API
function createMockClient() {
  const channels = new Map<string, { unsubscribe: () => void }>();

  return {
    from: (table: string) => ({
      select: (columns = "*") => ({
        eq: (col: string, val: any) => ({
          eq: (col2: string, val2: any) => ({
            single: async () => {
              try {
                let endpoint;
                // âœ… FIX 1: à¹€à¸žà¸´à¹ˆà¸¡ Logic à¹€à¸Šà¹‡à¸„ ID à¸ªà¸³à¸«à¸£à¸±à¸š Nested Query
                if (table === "rooms" && (col === "code" || col2 === "code")) {
                  const codeVal = col === "code" ? val : val2;
                  endpoint = `${API_URL}/api/rooms/${codeVal}`;
                } else if (col === "id") {
                  endpoint = `${API_URL}/api/${toApiEndpoint(table)}/${val}`;
                } else if (col2 === "id") {
                  endpoint = `${API_URL}/api/${toApiEndpoint(table)}/${val2}`;
                } else if (table === "players" && col === "room_id") {
                  endpoint = `${API_URL}/api/rooms/${val}/players`;
                } else if (table === "rooms" && col === "room_id") {
                  endpoint = `${API_URL}/api/rooms/${val}/players`;
                } else {
                  endpoint = `${API_URL}/api/${toApiEndpoint(table)}`;
                }

                console.log(
                  "ðŸ”— [Nested eq().eq().single()] Endpoint:",
                  endpoint,
                  "| Col:",
                  col,
                  "| Val:",
                  val,
                  "| Col2:",
                  col2,
                  "| Val2:",
                  val2
                );
                const res = await fetch(endpoint);
                if (!res.ok)
                  return { data: null, error: new Error("Not found") };
                const data = await res.json();
                return { data, error: null };
              } catch (e) {
                return { data: null, error: e };
              }
            },
            async then(resolve: any) {
              const result = await this.single();
              resolve(result);
            },
          }),
          single: async () => {
            try {
              let endpoint;
              // âœ… FIX 2: à¹€à¸žà¸´à¹ˆà¸¡ Logic à¹€à¸Šà¹‡à¸„ ID à¸ªà¸³à¸«à¸£à¸±à¸š Single Query
              if (table === "rooms" && col === "code") {
                endpoint = `${API_URL}/api/rooms/${val}`;
              } else if (col === "id") {
                endpoint = `${API_URL}/api/${toApiEndpoint(table)}/${val}`;
              } else if (table === "players" && col === "room_id") {
                endpoint = `${API_URL}/api/rooms/${val}/players`;
              } else if (table === "rooms" && col === "room_id") {
                endpoint = `${API_URL}/api/rooms/${val}/players`;
              } else {
                endpoint = `${API_URL}/api/${toApiEndpoint(table)}`;
              }

              console.log(
                "ðŸ”— [eq().single()] Endpoint:",
                endpoint,
                "| Table:",
                table,
                "| Col:",
                col,
                "| Val:",
                val
              );
              const res = await fetch(endpoint);
              if (!res.ok) return { data: null, error: new Error("Not found") };
              const data = await res.json();
              return { data, error: null };
            } catch (e) {
              return { data: null, error: e };
            }
          },
          async then(resolve: any) {
            try {
              // Handle single filter condition
              let endpoint;
              if (table === "players" && col === "room_id") {
                endpoint = `${API_URL}/api/rooms/${val}/players`;
              } else if (table === "rooms" && col === "room_id") {
                endpoint = `${API_URL}/api/rooms/${val}/players`;
              } else if (col === "id") {
                endpoint = `${API_URL}/api/${toApiEndpoint(table)}/${val}`;
              } else {
                endpoint = `${API_URL}/api/${toApiEndpoint(table)}`;
              }

              console.log(
                "ðŸ”— [eq().then()] Endpoint:",
                endpoint,
                "| Table:",
                table,
                "| Col:",
                col,
                "| Val:",
                val
              );
              const res = await fetch(endpoint);
              if (!res.ok) {
                resolve({
                  data: [],
                  error: new Error(`Failed to fetch: ${res.statusText}`),
                });
                return;
              }
              const data = await res.json();
              resolve({
                data: Array.isArray(data) ? data : [data],
                error: null,
              });
            } catch (e) {
              resolve({ data: [], error: e });
            }
          },
        }),
        order: () => ({
          async then(resolve: any) {
            try {
              console.log(
                "ðŸ”— [order().then()] Endpoint: /api/" + toApiEndpoint(table)
              );
              const res = await fetch(`${API_URL}/api/${toApiEndpoint(table)}`);
              const data = await res.json();
              resolve({ data: Array.isArray(data) ? data : [], error: null });
            } catch (e) {
              resolve({ data: [], error: e });
            }
          },
        }),
        async then(resolve: any) {
          try {
            console.log(
              "ðŸ”— [select().then()] Endpoint: /api/" + toApiEndpoint(table)
            );
            const res = await fetch(`${API_URL}/api/${toApiEndpoint(table)}`);
            const data = await res.json();
            resolve({ data: Array.isArray(data) ? data : [], error: null });
          } catch (e) {
            resolve({ data: [], error: e });
          }
        },
      }),
      insert: (row: any) => ({
        select: () => ({
          single: async () => {
            try {
              const endpoint = `${API_URL}/api/${toApiEndpoint(table)}`;
              const res = await fetch(endpoint, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(row),
              });
              if (!res.ok) {
                const errorText = await res.text();
                return {
                  data: null,
                  error: new Error(errorText || "Insert failed"),
                };
              }
              const data = await res.json();
              return { data, error: null };
            } catch (e) {
              return { data: null, error: e };
            }
          },
          async then(resolve: any) {
            try {
              const endpoint = `${API_URL}/api/${toApiEndpoint(table)}`;
              const isArray = Array.isArray(row);

              if (isArray) {
                // Insert multiple rows
                const results = [];
                for (const item of row) {
                  const res = await fetch(endpoint, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(item),
                  });
                  if (res.ok) {
                    results.push(await res.json());
                  }
                }
                resolve({ data: results, error: null });
              } else {
                // Insert single row
                const res = await fetch(endpoint, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(row),
                });
                if (!res.ok) {
                  const errorText = await res.text();
                  resolve({
                    data: null,
                    error: new Error(errorText || "Insert failed"),
                  });
                  return;
                }
                const data = await res.json();
                resolve({ data: [data], error: null });
              }
            } catch (e) {
              resolve({ data: null, error: e });
            }
          },
        }),
        async then(resolve: any) {
          try {
            const endpoint = `${API_URL}/api/${toApiEndpoint(table)}`;
            const isArray = Array.isArray(row);

            if (isArray) {
              // Insert multiple rows
              const results = [];
              for (const item of row) {
                const res = await fetch(endpoint, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(item),
                });
                if (res.ok) {
                  results.push(await res.json());
                }
              }
              resolve({ data: results, error: null });
            } else {
              // Insert single row
              const res = await fetch(endpoint, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(row),
              });
              if (!res.ok) {
                const errorText = await res.text();
                resolve({
                  data: null,
                  error: new Error(errorText || "Insert failed"),
                });
                return;
              }
              const data = await res.json();
              resolve({ data, error: null });
            }
          } catch (e) {
            resolve({ data: null, error: e });
          }
        },
      }),
      update: (data: any) => ({
        eq: (col: string, val: any) => ({
          eq: (col2: string, val2: any) => ({
            async then(resolve: any) {
              try {
                const endpoint = `${API_URL}/api/${toApiEndpoint(
                  table
                )}/${val}`;
                const res = await fetch(endpoint, {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(data),
                });
                if (!res.ok) {
                  const errorText = await res.text();
                  resolve({ error: new Error(errorText || "Update failed") });
                  return;
                }
                resolve({ error: null });
              } catch (e) {
                resolve({ error: e });
              }
            },
          }),
          async then(resolve: any) {
            try {
              const endpoint = `${API_URL}/api/${toApiEndpoint(table)}/${val}`;
              const res = await fetch(endpoint, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(data),
              });
              if (!res.ok) {
                const errorText = await res.text();
                resolve({
                  error: new Error(errorText || "Update failed"),
                  data: null,
                });
                return;
              }
              resolve({ error: null, data: null });
            } catch (e) {
              resolve({ error: e });
            }
          },
        }),
      }),
      delete: () => ({
        eq: (col: string, val: any) => ({
          async then(resolve: any) {
            try {
              const endpoint = `${API_URL}/api/${toApiEndpoint(table)}/${val}`;
              const res = await fetch(endpoint, {
                method: "DELETE",
              });
              if (!res.ok) {
                const errorText = await res.text();
                resolve({ error: new Error(errorText || "Delete failed") });
                return;
              }
              resolve({ error: null });
            } catch (e) {
              resolve({ error: e });
            }
          },
        }),
        in: (col: string, vals: any[]) => ({
          async then(resolve: any) {
            try {
              for (const val of vals) {
                const endpoint = `${API_URL}/api/${toApiEndpoint(
                  table
                )}/${val}`;
                await fetch(endpoint, {
                  method: "DELETE",
                });
              }
              resolve({ error: null });
            } catch (e) {
              resolve({ error: e });
            }
          },
        }),
      }),
    }),
    channel: (name: string) => {
      const callbacks: { event: string; callback: (payload: any) => void }[] =
        [];
      let roomCode: string | null = null;

      // Extract room ID from channel name (e.g., "room-abc123")
      const match = name.match(/room-([a-zA-Z0-9-]+)/);
      if (match) roomCode = match[1];

      const channel = {
        on: (event: string, filter: any, callback: (payload: any) => void) => {
          callbacks.push({ event, callback });
          return channel;
        },
        subscribe: (statusCallback?: (status: string) => void) => {
          if (roomCode) {
            socketClient.joinRoom(roomCode);

            // Map Socket.IO events to Supabase-like payloads
            socketClient.on("room-changed", (data: any) => {
              callbacks.forEach(({ callback }) =>
                callback({ eventType: "UPDATE", new: data })
              );
            });
            socketClient.on("player-joined", (data: any) => {
              callbacks.forEach(({ callback }) =>
                callback({ eventType: "INSERT", new: data })
              );
            });
            socketClient.on("player-left", (data: any) => {
              callbacks.forEach(({ callback }) =>
                callback({ eventType: "DELETE", old: { id: data.playerId } })
              );
            });
            socketClient.on("player-changed", (data: any) => {
              callbacks.forEach(({ callback }) =>
                callback({ eventType: "UPDATE", new: data })
              );
            });
          }

          if (statusCallback) {
            setTimeout(() => statusCallback("SUBSCRIBED"), 100);
          }
          return channel;
        },
      };

      channels.set(name, {
        unsubscribe: () => {
          if (roomCode) socketClient.leaveRoom(roomCode);
        },
      });

      return channel;
    },
    removeChannel: (channel: any) => {
      // Cleanup handled by channel.unsubscribe
    },
    functions: {
      invoke: async <T>(name: string, options: { body: any }) => {
        try {
          const res = await fetch(`${API_URL}/api/${name.replace("-", "/")}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(options.body),
          });
          const data = await res.json();
          return { data: data as T, error: null };
        } catch (e) {
          return { data: null, error: e };
        }
      },
    },
    realtime: {
      connect: () => {
        socketClient.connect();
        return Promise.resolve();
      },
    },
  };
}

export const supabase = createMockClient();
